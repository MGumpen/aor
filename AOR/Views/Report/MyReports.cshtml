@model IEnumerable<AOR.Models.ReportModel>

@{
    ViewData["Title"] = "My Reports";
    Layout = "_Layout";
}

<style>
    .container {
        max-width: 1200px;
        margin: 0 auto;
        padding: 24px;
    }
    
    .header {
        margin-bottom: 32px;
        text-align: center;
    }
    
    /* Separate grids for drafts and registered obstacles */
    #draftsContainer {
        display: grid;
        grid-template-columns: repeat(auto-fill, minmax(280px, 1fr));  /* Smaller cards */
        gap: 16px;  /* Less gap for drafts */
        margin-bottom: 32px;
    }
    
    .obstacles-grid {
        display: grid;
        grid-template-columns: repeat(auto-fill, minmax(350px, 1fr));  /* Regular size */
        gap: 20px;
    }
    
    .obstacle-card {
        background: white;
        border: 1px solid #e5e7eb;
        border-radius: 16px;
        padding: 20px;
        box-shadow: 0 2px 8px rgba(0,0,0,0.08);
        transition: all 0.2s ease;
    }
    
    /* Draft cards smaller styling */
    #draftsContainer .obstacle-card {
        padding: 16px;  /* Less padding */
        border-radius: 12px;  /* Slightly less rounded */
    }
    
    .obstacle-card:hover {
        transform: translateY(-2px);
        box-shadow: 0 4px 16px rgba(0,0,0,0.12);
    }
    
    .obstacle-header {
        display: flex;
        justify-content: space-between;
        align-items: flex-start;
        margin-bottom: 16px;
    }
    
    .obstacle-name {
        font-size: 1.25rem;
        font-weight: 600;
        color: #1e293b;
        margin: 0;
    }
    
    /* Smaller title for drafts */
    #draftsContainer .obstacle-name {
        font-size: 1.1rem;
    }
    
    .obstacle-type-badge {
        padding: 4px 12px;
        border-radius: 20px;
        font-size: 11px;
        font-weight: 600;
        text-transform: uppercase;
    }
    
    .badge-powerline { background: #fee2e2; color: #dc2626; }
    .badge-mast { background: #dbeafe; color: #2563eb; }
    .badge-other { background: #d1fae5; color: #059669; }
    
    .obstacle-details {
        display: grid;
        grid-template-columns: 1fr 1fr;
        gap: 12px;
        margin-bottom: 16px;
    }
    
    /* Smaller details for drafts */
    #draftsContainer .obstacle-details {
        gap: 8px;
        margin-bottom: 12px;
    }
    
    .detail-item {
        font-size: 0.875rem;
    }
    
    /* Smaller font for draft details */
    #draftsContainer .detail-item {
        font-size: 0.8125rem;
    }
    
    .detail-label {
        color: #64748b;
        font-weight: 500;
    }
    
    .detail-value {
        color: #1e293b;
        font-weight: 400;
    }
    
    .obstacle-description {
        background: #f8fafc;
        border-radius: 8px;
        padding: 12px;
        margin-bottom: 16px;
        font-size: 0.875rem;
        color: #475569;
    }
    
    /* Smaller description for drafts */
    #draftsContainer .obstacle-description {
        padding: 10px;
        margin-bottom: 12px;
        font-size: 0.8125rem;
    }
    
    .report-actions {
        display: flex;
        gap: 8px;
        justify-content: flex-end;
    }
    
    .btn-small {
        padding: 6px 12px;
        border-radius: 6px;
        text-decoration: none;
        font-size: 0.75rem;
        font-weight: 500;
        text-align: center;
        transition: all 0.2s ease;
    }
    
    .btn-details {
        background: #f1f5f9;
        color: #475569;
        border: 1px solid #e2e8f0;
    }
    
    .btn-details:hover {
        background: #e2e8f0;
        color: #334155;
    }
    
    .empty-state {
        text-align: center;
        padding: 60px 20px;
        color: #64748b;
    }
    
    .empty-icon {
        font-size: 4rem;
        margin-bottom: 16px;
    }
    
    .actions-bar {
        display: flex;
        justify-content: space-between;
        align-items: center;
        margin-bottom: 24px;
        padding: 16px;
        background: white;
        border-radius: 12px;
        box-shadow: 0 1px 4px rgba(0,0,0,0.05);
    }
    
    .stats {
        display: flex;
        gap: 24px;
        font-size: 0.875rem;
        color: #64748b;
    }
    
    .btn {
        padding: 10px 20px;
        border-radius: 8px;
        text-decoration: none;
        font-weight: 500;
        transition: all 0.2s ease;
        display: inline-block;
    }
    
    .btn-primary {
        background: #4f46e5;
        color: white;
    }
    
    .btn-primary:hover {
        background: #4338ca;
        color: white;
    }

    .status-badge {
        display: inline-block;
        padding: 4px 10px;
        border-radius: 12px;
        font-size: 0.75rem;
        font-weight: 600;
        text-transform: uppercase;
    }
    .status-badge-pending {
        background: #fef3c7;
        color: #b45309;
    }
    .status-badge-approved {
        background: #dcfce7;
        color: #166534;
    }
    .status-badge-rejected {
        background: #fee2e2;
        color: #991b1b;
    }
</style>


<section class="container">
    <div class="header">
        <h1>My Reports</h1>
        <p style="color: #64748b;">Overview of obstacles you have reported</p>
    </div>
    
    <div class="actions-bar">
        <div class="stats">
            <div><strong>Total:</strong> @(Model == null ? 0 : Model.Count()) reports</div>
            <div><strong>Power Lines:</strong> @(Model == null ? 0 : Model.Count(x => x.Obstacle != null && !string.IsNullOrEmpty(x.Obstacle.ObstacleType) && x.Obstacle.ObstacleType.ToLower() == "powerline"))</div>
            <div><strong>Masts:</strong> @(Model == null ? 0 : Model.Count(x => x.Obstacle != null && !string.IsNullOrEmpty(x.Obstacle.ObstacleType) && x.Obstacle.ObstacleType.ToLower() == "mast"))</div>
            <div><strong>Other:</strong> @(Model == null ? 0 : Model.Count(x => x.Obstacle != null && !string.IsNullOrEmpty(x.Obstacle.ObstacleType) && x.Obstacle.ObstacleType.ToLower() == "other"))</div>
            <div id="draftsStats" style="display:none;"><strong>Drafts:</strong> <span id="draftsNumber">0</span></div>
        </div>
        <a href="/Crew" class="btn btn-primary">Add New Obstacle</a>
    </div>
    
    <div class="obstacles-grid" id="draftsContainer" style="display: none; margin-bottom: 24px;"></div>

    @if (Model != null && Model.Any())
    {
        <div class="obstacles-grid">
            @foreach (var report in Model.OrderByDescending(x => x.CreatedAt))
            {
                <div class="obstacle-card">
                    <div class="obstacle-header">
                        <h3 class="obstacle-name">@report.Obstacle?.ObstacleName</h3>
                        @{
                            var type = (report.Obstacle?.ObstacleType ?? "other").ToLower();
                        }
                        <span class="obstacle-type-badge badge-@type">
                            @report.Obstacle?.ObstacleType
                        </span>
                    </div>
                    
                    <div class="obstacle-details">
                        @if (report.Obstacle?.ObstacleHeight.HasValue == true)
                        {
                            <div class="detail-item">
                                <div class="detail-label">Height:</div>
                                <div class="detail-value">@($"{report.Obstacle.ObstacleHeight.Value:F1} m")</div>
                            </div>
                        }
                        
                        <div class="detail-item">
                            <div class="detail-label">Points:</div>
                            <div class="detail-value">@report.Obstacle?.PointCount</div>
                        </div>
                        
                        <div class="detail-item">
                            <div class="detail-label">Registered:</div>
                            <div class="detail-value">@report.CreatedAt.ToString("dd.MM.yyyy")</div>
                        </div>
                        
                        <div class="detail-item">
                            <div class="detail-label">Status:</div>
                            <div class="detail-value">
                                @{
                                    var statusText = report.Status?.Status ?? "Pending";
                                    var badgeClass = statusText.ToLower() switch
                                    {
                                        "approved" => "status-badge status-badge-approved",
                                        "rejected" => "status-badge status-badge-rejected",
                                        _ => "status-badge status-badge-pending"
                                    };
                                }
                                <span class="@badgeClass">@statusText</span>
                            </div>
                        </div>
                        
                        @if (!string.IsNullOrEmpty(report.Obstacle?.ObstacleType)
                             && report.Obstacle.ObstacleType.ToLower() == "mast"
                             && !string.IsNullOrEmpty(report.Obstacle.MastType))
                        {
                            <div class="detail-item">
                                <div class="detail-label">Type:</div>
                                <div class="detail-value">@report.Obstacle.MastType</div>
                            </div>
                        }
                    </div>
                    
                    @if (!string.IsNullOrEmpty(report.Obstacle?.ObstacleDescription))
                    {
                        <div class="obstacle-description">
                            @(report.Obstacle.ObstacleDescription.Length > 100 ? 
                              report.Obstacle.ObstacleDescription.Substring(0, 100) + "..." : 
                              report.Obstacle.ObstacleDescription)
                        </div>
                    }
                    
                    <div class="report-actions">
                        <a asp-controller="Report" asp-action="ReportDetails" asp-route-id="@report.ReportId" class="btn-small btn-details">View Details</a>
                    </div>
                </div>
            }
        </div>
    }
    else
    {
        <div class="empty-state">
            <div class="empty-icon">üìç</div>
            <h3>No Reports Found</h3>
            <p>You haven't reported any obstacles yet.</p>
            <a href="/Crew" class="btn btn-primary">Register an Obstacle</a>
        </div>
    }
</section>

<script>
    (function () {
        if (typeof window === 'undefined') {
            return;
        }

        let draftKeyToDelete = null;

        @if (TempData["DeleteDraft"] != null)
        {
            <text>draftKeyToDelete = @Html.Raw(System.Text.Json.JsonSerializer.Serialize(TempData["DeleteDraft"]));</text>
        }

        if (!draftKeyToDelete && window.sessionStorage) {
            draftKeyToDelete = window.sessionStorage.getItem('deleteDraft');
        }

        if (!draftKeyToDelete) {
            return;
        }

        try {
            if (window.sessionStorage) {
                window.sessionStorage.removeItem('deleteDraft');
            }

            if (window.localStorage && window.localStorage.getItem(draftKeyToDelete)) {
                window.localStorage.removeItem(draftKeyToDelete);
            }
        } catch (error) {
            console.warn('Unable to clear stored draft state', draftKeyToDelete, error);
        }
    })();
</script>

<script>
    (function () {
        const draftsContainer = document.getElementById('draftsContainer');
        if (!draftsContainer) {
            return;
        }

        const draftKeys = Object.keys(localStorage)
            .filter(key => key.startsWith('draft_'))
            .map(key => {
                try {
                    const raw = localStorage.getItem(key);
                    if (!raw) {
                        return null;
                    }

                    const data = JSON.parse(raw);
                    const canonical = canonicalizeDraftData(data);
                    try {
                        localStorage.setItem(key, JSON.stringify(canonical));
                    } catch (saveError) {
                        console.warn('Unable to rewrite canonical draft entry', key, saveError);
                    }

                    return { key, data: canonical };
                } catch (error) {
                    console.warn('Unable to parse draft entry', key, error);
                    return null;
                }
            })
            .filter(entry => entry && entry.data);

        if (!draftKeys.length) {
            return;
        }

        draftKeys.sort((a, b) => {
            const aDate = new Date(a.data.savedAt || 0).getTime();
            const bDate = new Date(b.data.savedAt || 0).getTime();
            return bDate - aDate;
        });

        draftsContainer.style.display = 'grid';
        draftsContainer.innerHTML = '';

        const emptyState = document.querySelector('.empty-state');
        if (emptyState) {
            emptyState.style.display = 'none';
        }

        const draftsStats = document.getElementById('draftsStats');
        const draftsNumber = document.getElementById('draftsNumber');
        if (draftsStats && draftsNumber) {
            draftsStats.style.display = 'block';
            draftsNumber.textContent = draftKeys.length.toString();
        }

        draftKeys.forEach(entry => {
            const { key, data } = entry;
            const card = document.createElement('div');
            card.className = 'obstacle-card';
            card.dataset.draftKey = key;
            card.style.background = '#fffbe8';
            card.style.border = '1px solid #fde68a';

            const header = document.createElement('div');
            header.className = 'obstacle-header';

            const title = document.createElement('h3');
            title.className = 'obstacle-name';
            const candidateName = getFirstNonEmpty(
                data.ObstacleName,
                data.obstacleName,
                data.displayName,
                data.draftTitle,
                data.title,
                data.name,
                data.ObstacleId,
                data.obstacleId
            );

            title.textContent = candidateName ? candidateName.toString() : 'Draft Unknown';

            // Get obstacle type for badge display
            const obstacleTypeRawValue = getFirstNonEmpty(
                data.ObstacleType,
                data.obstacleType,
                data.type,
                data.hiddenObstacleType,
                data['ObstacleData.ObstacleType'],
                data['obstacle_data.obstacle_type']
            );
            const obstacleTypeRaw = (obstacleTypeRawValue || '').toString().trim();
            const obstacleType = obstacleTypeRaw.toLowerCase();
            const formattedType = formatObstacleType(obstacleTypeRaw);

            // Create type badge (like registered obstacles)
            const typeBadge = document.createElement('span');
            typeBadge.className = `obstacle-type-badge badge-${obstacleType || 'other'}`;
            typeBadge.textContent = formattedType;

            header.appendChild(title);
            header.appendChild(typeBadge);
            card.appendChild(header);

            const details = document.createElement('div');
            details.className = 'obstacle-details';

            const formattedHeight = formatDraftHeight(data.ObstacleHeight, data.heightInput);
            const pointCount = deriveDraftPointCount(data);

            // Updated detail items WITHOUT the "Type:" row
            const detailItems = [
                { label: 'Height:', value: formattedHeight },
                { label: 'Points:', value: pointCount.toString() },
                { label: 'Registered:', value: formatSavedDate(data.savedAt) },
                { label: 'Status:', value: null, badge: 'DRAFT' }
            ];

            detailItems.forEach(item => {
                const wrapper = document.createElement('div');
                wrapper.className = 'detail-item';

                const label = document.createElement('div');
                label.className = 'detail-label';
                label.textContent = item.label;

                const value = document.createElement('div');
                value.className = 'detail-value';

                if (item.badge) {
                    const statusBadge = document.createElement('span');
                    statusBadge.className = 'status-badge status-badge-pending';
                    statusBadge.style.background = '#fef3c7';
                    statusBadge.style.color = '#b45309';
                    statusBadge.textContent = item.badge;
                    value.appendChild(statusBadge);
                } else {
                    value.textContent = item.value ?? '‚Äî';
                }

                wrapper.appendChild(label);
                wrapper.appendChild(value);
                details.appendChild(wrapper);
            });

            card.appendChild(details);

            if (data.ObstacleDescription && data.ObstacleDescription.trim() !== '') {
                const description = document.createElement('div');
                description.className = 'obstacle-description';

                const text = data.ObstacleDescription.length > 80
                    ? `${data.ObstacleDescription.substring(0, 80)}...`
                    : data.ObstacleDescription;

                description.textContent = text;
                card.appendChild(description);
            }

            const actions = document.createElement('div');
            actions.className = 'report-actions';

            const continueLink = document.createElement('a');
            continueLink.className = 'btn-small btn-details';
            const continueParams = new URLSearchParams();
            continueParams.set('draft', key);

            if (obstacleType) {
                continueParams.set('type', obstacleType);
            }

            if (data.Coordinates) {
                continueParams.set('coordinates', data.Coordinates);
            }

            if (!Number.isNaN(pointCount) && pointCount >= 0) {
                continueParams.set('count', pointCount.toString());
            }

            continueLink.href = `/Obstacle/DataForm?${continueParams.toString()}`;
            continueLink.textContent = 'Continue Editing';

            const deleteLink = document.createElement('a');
            deleteLink.className = 'btn-small btn-details';
            deleteLink.style.background = '#fee2e2';
            deleteLink.style.color = '#991b1b';
            deleteLink.style.border = '1px solid #fee2e2';
            deleteLink.href = '#';
            deleteLink.textContent = 'Delete Draft';
            deleteLink.addEventListener('click', function (event) {
                event.preventDefault();

                if (confirm('Delete this draft?')) {
                    localStorage.removeItem(key);
                    card.remove();

                    const remaining = draftsContainer.querySelectorAll('.obstacle-card').length;
                    if (draftsStats && draftsNumber) {
                        if (remaining === 0) {
                            draftsStats.style.display = 'none';
                            draftsContainer.style.display = 'none';
                            const emptyStateAfterDelete = document.querySelector('.empty-state');
                            if (emptyStateAfterDelete) {
                                emptyStateAfterDelete.style.display = '';
                            }
                        }
                        draftsNumber.textContent = remaining.toString();
                    }
                }
            });

            actions.appendChild(continueLink);
            actions.appendChild(deleteLink);
            card.appendChild(actions);

            draftsContainer.appendChild(card);
        });

        // All helper functions remain the same
        function formatSavedDate(value) {
            if (!value) {
                return 'Just now';
            }

            const date = new Date(value);
            if (Number.isNaN(date.getTime())) {
                return 'Just now';
            }

            const diffMs = Date.now() - date.getTime();
            if (diffMs < 0) {
                return 'Just now';
            }

            const seconds = Math.floor(diffMs / 1000);
            const minutes = Math.floor(seconds / 60);
            const hours = Math.floor(minutes / 60);
            const days = Math.floor(hours / 24);
            if (seconds < 5) return 'Just now';
            if (seconds < 60) return `${seconds} seconds ago`;
            if (minutes === 1) return '1 minute ago';
            if (minutes < 60) return `${minutes} minutes ago`;
            if (hours === 1) return '1 hour ago';
            if (hours < 24) return `${hours} hours ago`;
            if (days === 1) return '1 day ago';
            if (days === 2) return '2 days ago';
            if (days >= 3) return date.toLocaleDateString('no-NO');

            return date.toLocaleDateString('no-NO');
        }

        function deriveDraftPointCount(data) {
            if (!data) {
                return 0;
            }

            const count = Number(data.PointCount);
            if (!Number.isNaN(count) && count >= 0) {
                return count;
            }

            if (data.Coordinates) {
                try {
                    const coordinates = typeof data.Coordinates === 'string'
                        ? JSON.parse(data.Coordinates)
                        : data.Coordinates;

                    if (Array.isArray(coordinates)) {
                        return coordinates.length;
                    }
                } catch (error) {
                    console.warn('Unable to parse coordinates for draft card', error);
                }
            }

            return 0;
        }

        function formatDraftHeight(valueMeters, valueFeet) {
            let meters = Number(valueMeters);

            if (Number.isNaN(meters) || meters <= 0) {
                const feet = Number(valueFeet);
                if (!Number.isNaN(feet) && feet > 0) {
                    meters = feet * 0.3048;
                }
            }

            if (Number.isNaN(meters) || meters <= 0) {
                return '‚Äî';
            }

            return `${meters.toFixed(1)} m`;
        }

        function formatObstacleType(value) {
            if (!value) {
                return 'Unknown';
            }

            const lower = value.toLowerCase();
            switch (lower) {
                case 'mast':
                    return 'Mast';
                case 'powerline':
                    return 'Power Line';
                case 'other':
                    return 'Other';
                default:
                    return value.charAt(0).toUpperCase() + value.slice(1);
            }
        }

        function formatYesNo(value) {
            if (typeof value === 'boolean') {
                return value ? 'Yes' : 'No';
            }

            if (typeof value === 'string') {
                const trimmed = value.trim().toLowerCase();
                if (trimmed === 'true') {
                    return 'Yes';
                }
                if (trimmed === 'false') {
                    return 'No';
                }
            }

            return value || '‚Äî';
        }

        function canonicalizeDraftData(source = {}) {
            const data = { ...source };

            const getFirstValue = (...keys) => getFirstNonEmptyFrom(data, ...keys);

            const setCanonicalField = (canonicalKey, ...aliases) => {
                const value = getFirstValue(canonicalKey, ...aliases);
                if (value !== undefined) {
                    data[canonicalKey] = value;
                }
            };

            setCanonicalField('ObstacleName', 'obstacleName', 'name', 'ObstacleId', 'obstacleId', 'draftTitle', 'title', 'displayName', 'ObstacleData.ObstacleName', 'obstacle_data.obstacle_name');
            setCanonicalField('ObstacleType', 'obstacleType', 'type', 'ObstacleData.ObstacleType', 'obstacle_data.obstacle_type', 'hiddenObstacleType');
            setCanonicalField('ObstacleDescription', 'obstacleDescription', 'description', 'ObstacleData.ObstacleDescription', 'obstacle_data.obstacle_description');
            setCanonicalField('ObstacleHeight', 'obstacleHeight', 'heightMeters', 'height', 'Height', 'ObstacleData.ObstacleHeight', 'obstacle_data.obstacle_height');
            setCanonicalField('heightInput', 'heightFeet', 'HeightFeet', 'height_ft', 'feetHeight', 'ObstacleData.heightInput', 'obstacle_data.height_input');
            setCanonicalField('WireCount', 'wireCount', 'wires', 'wire_count', 'numberOfWires', 'wireTotal', 'ObstacleData.WireCount', 'obstacle_data.wire_count');
            setCanonicalField('MastType', 'mastType', 'towerType', 'mast_type', 'tower_type', 'ObstacleData.MastType', 'obstacle_data.mast_type');
            setCanonicalField('HasLighting', 'hasLighting', 'lighting', 'Lighting', 'has_lighting', 'ObstacleData.HasLighting', 'obstacle_data.has_lighting');
            setCanonicalField('Category', 'category', 'obstacleCategory', 'obstacle_category', 'ObstacleData.Category', 'obstacle_data.category');
            setCanonicalField('Coordinates', 'coordinates', 'pointsJson', 'ObstacleData.Coordinates', 'obstacle_data.coordinates', 'coordinatesJson');
            setCanonicalField('PointCount', 'pointCount', 'points', 'ObstacleData.PointCount', 'obstacle_data.point_count');
            setCanonicalField('savedAt', 'SavedAt', 'saved_at', 'ObstacleData.SavedAt', 'obstacle_data.saved_at', 'timestamp');

            if (data.ObstacleType) {
                data.ObstacleType = data.ObstacleType.toString().trim();
            }

            if (typeof data.HasLighting === 'boolean') {
                data.HasLighting = data.HasLighting ? 'true' : 'false';
            } else if (typeof data.HasLighting === 'string') {
                const trimmed = data.HasLighting.trim().toLowerCase();
                if (trimmed === 'yes') {
                    data.HasLighting = 'true';
                } else if (trimmed === 'no') {
                    data.HasLighting = 'false';
                } else {
                    data.HasLighting = data.HasLighting.trim();
                }
            }

            if (data.Coordinates && typeof data.Coordinates !== 'string') {
                try {
                    data.Coordinates = JSON.stringify(data.Coordinates);
                } catch (error) {
                    console.warn('Unable to stringify coordinates during canonicalization', error);
                    data.Coordinates = '[]';
                }
            }

            const parsedHeight = Number(data.ObstacleHeight);
            if (!Number.isNaN(parsedHeight) && parsedHeight > 0) {
                data.ObstacleHeight = parsedHeight;
            }

            if ((!data.heightInput || data.heightInput === '') && parsedHeight > 0) {
                const feet = parsedHeight / 0.3048;
                data.heightInput = (Math.round(feet * 10) / 10).toString();
            }

            data.PointCount = deriveDraftPointCount(data);

            ['ObstacleName', 'ObstacleDescription', 'MastType', 'Category', 'WireCount', 'heightInput', 'draftTitle', 'displayName'].forEach(key => {
                if (typeof data[key] === 'string') {
                    data[key] = data[key].trim();
                }
            });

            if (!data.draftTitle && data.ObstacleName) {
                data.draftTitle = data.ObstacleName;
            }

            if (!data.displayName && data.ObstacleName) {
                data.displayName = data.ObstacleName;
            }

            return data;
        }

        function getFirstNonEmpty(...values) {
            for (const value of values) {
                if (value === undefined || value === null) {
                    continue;
                }

                const candidate = typeof value === 'string' ? value.trim() : value;
                if (candidate !== '' && !(typeof candidate === 'number' && Number.isNaN(candidate))) {
                    return candidate;
                }
            }

            return undefined;
        }

        function getFirstNonEmptyFrom(data, ...keys) {
            for (const key of keys) {
                if (Object.prototype.hasOwnProperty.call(data, key)) {
                    const candidate = data[key];
                    if (candidate !== undefined && candidate !== null) {
                        if (typeof candidate === 'string') {
                            const trimmed = candidate.trim();
                            if (trimmed !== '') {
                                return trimmed;
                            }
                        } else if (!(typeof candidate === 'number' && Number.isNaN(candidate))) {
                            return candidate;
                        }
                    }
                }
            }

            return undefined;
        }
    })();
</script>
