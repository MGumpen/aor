<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/AOR/Data/AorDbSeeder.cs">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/AOR/Data/AorDbSeeder.cs" />
              <option name="originalContent" value="namespace AOR.Data;&#10;&#10;public class AorDbSeeder&#10;{&#10;    &#10;}" />
              <option name="updatedContent" value="using System;&#10;using System.Linq;&#10;using System.Threading.Tasks;&#10;using Microsoft.AspNetCore.Identity;&#10;using Microsoft.Extensions.DependencyInjection;&#10;using Microsoft.Extensions.Logging;&#10;&#10;namespace AOR.Data;&#10;&#10;public static class AorDbSeeder&#10;{&#10;    /// &lt;summary&gt;&#10;    /// Seed roles and test users into the Identity store.&#10;    /// Call this during application startup after DbContext has been registered.&#10;    /// &lt;/summary&gt;&#10;    public static async Task SeedAsync(IServiceProvider serviceProvider, ILogger logger)&#10;    {&#10;        using var scope = serviceProvider.CreateScope();&#10;        var scoped = scope.ServiceProvider;&#10;&#10;        // Try to log DB provider if available&#10;        try&#10;        {&#10;            var db = scoped.GetService&lt;AorDbContext&gt;();&#10;            if (db != null)&#10;            {&#10;                logger.LogInformation(&quot;Database provider: {Provider}&quot;, db.Database.ProviderName ?? &quot;(unknown)&quot;);&#10;            }&#10;        }&#10;        catch { /* ignore logging errors */ }&#10;&#10;        RoleManager&lt;IdentityRole&gt; roleManager;&#10;        UserManager&lt;User&gt; userManager;&#10;        try&#10;        {&#10;            roleManager = scoped.GetRequiredService&lt;RoleManager&lt;IdentityRole&gt;&gt;();&#10;            userManager = scoped.GetRequiredService&lt;UserManager&lt;User&gt;&gt;();&#10;        }&#10;        catch (Exception ex)&#10;        {&#10;            logger.LogWarning(ex, &quot;RoleManager or UserManager not available; skipping identity seeding.&quot;);&#10;            return;&#10;        }&#10;&#10;        // Roles to ensure&#10;        var roles = new[] { &quot;Crew&quot;, &quot;Admin&quot;, &quot;Registrar&quot; };&#10;        foreach (var role in roles)&#10;        {&#10;            if (!await roleManager.RoleExistsAsync(role))&#10;            {&#10;                var createResult = await roleManager.CreateAsync(new IdentityRole(role));&#10;                if (createResult.Succeeded)&#10;                {&#10;                    logger.LogInformation(&quot;Created role '{Role}'&quot;, role);&#10;                }&#10;                else&#10;                {&#10;                    logger.LogWarning(&quot;Failed to create role '{Role}': {Errors}&quot;, role, string.Join(&quot;; &quot;, createResult.Errors.Select(e =&gt; e.Description)));&#10;                }&#10;            }&#10;            else&#10;            {&#10;                logger.LogInformation(&quot;Role '{Role}' already exists&quot;, role);&#10;            }&#10;        }&#10;&#10;        // Test users&#10;        var testUsers = new[]&#10;        {&#10;            new { Email = &quot;crew@test.local&quot;, Password = &quot;Test123$&quot;, Role = &quot;Crew&quot;, FirstName = &quot;Crew&quot;, LastName = &quot;User&quot; },&#10;            new { Email = &quot;admin@test.local&quot;, Password = &quot;Test123$&quot;, Role = &quot;Admin&quot;, FirstName = &quot;Admin&quot;, LastName = &quot;User&quot; },&#10;            new { Email = &quot;registrar@test.local&quot;, Password = &quot;Test123$&quot;, Role = &quot;Registrar&quot;, FirstName = &quot;Registrar&quot;, LastName = &quot;User&quot; }&#10;        };&#10;&#10;        foreach (var tu in testUsers)&#10;        {&#10;            try&#10;            {&#10;                var existing = await userManager.FindByEmailAsync(tu.Email);&#10;                if (existing == null)&#10;                {&#10;                    var user = new User&#10;                    {&#10;                        UserName = tu.Email,&#10;                        Email = tu.Email,&#10;                        EmailConfirmed = true,&#10;                        FirstName = tu.FirstName,&#10;                        LastName = tu.LastName&#10;                    };&#10;&#10;                    var createRes = await userManager.CreateAsync(user, tu.Password);&#10;                    if (!createRes.Succeeded)&#10;                    {&#10;                        logger.LogWarning(&quot;Failed to create user {Email}: {Errors}&quot;, tu.Email, string.Join(&quot;; &quot;, createRes.Errors.Select(e =&gt; e.Description)));&#10;                        continue;&#10;                    }&#10;&#10;                    var addRoleRes = await userManager.AddToRoleAsync(user, tu.Role);&#10;                    if (!addRoleRes.Succeeded)&#10;                    {&#10;                        logger.LogWarning(&quot;Failed to add role {Role} to user {Email}: {Errors}&quot;, tu.Role, tu.Email, string.Join(&quot;; &quot;, addRoleRes.Errors.Select(e =&gt; e.Description)));&#10;                    }&#10;                    else&#10;                    {&#10;                        logger.LogInformation(&quot;Created user {Email} with role {Role}&quot;, tu.Email, tu.Role);&#10;                    }&#10;                }&#10;                else&#10;                {&#10;                    // Ensure role is assigned&#10;                    var rolesForUser = await userManager.GetRolesAsync(existing);&#10;                    if (!rolesForUser.Contains(tu.Role))&#10;                    {&#10;                        var addRoleRes = await userManager.AddToRoleAsync(existing, tu.Role);&#10;                        if (!addRoleRes.Succeeded)&#10;                        {&#10;                            logger.LogWarning(&quot;Failed to add missing role {Role} to existing user {Email}: {Errors}&quot;, tu.Role, tu.Email, string.Join(&quot;; &quot;, addRoleRes.Errors.Select(e =&gt; e.Description)));&#10;                        }&#10;                        else&#10;                        {&#10;                            logger.LogInformation(&quot;Added missing role {Role} to existing user {Email}&quot;, tu.Role, tu.Email);&#10;                        }&#10;                    }&#10;                    else&#10;                    {&#10;                        logger.LogInformation(&quot;User {Email} already exists and has role {Role}&quot;, tu.Email, tu.Role);&#10;                    }&#10;                }&#10;            }&#10;            catch (Exception ex)&#10;            {&#10;                logger.LogError(ex, &quot;Exception while seeding user {Email}&quot;, tu.Email);&#10;            }&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/AOR/Program.cs">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/AOR/Program.cs" />
              <option name="originalContent" value="using Microsoft.EntityFrameworkCore;&#10;using AOR.Data;&#10;using Microsoft.AspNetCore.Authentication.Cookies;&#10;using Microsoft.AspNetCore.Identity;&#10;&#10;&#10;var builder = WebApplication.CreateBuilder(args);&#10;&#10;// Add services&#10;builder.Services.AddControllersWithViews();&#10;&#10;// Database configuration - MySQL&#10;var connectionString = builder.Configuration.GetConnectionString(&quot;AorDb&quot;);&#10;builder.Services.AddDbContext&lt;AorDbContext&gt;(options =&gt;&#10;    options.UseMySql(connectionString, new MySqlServerVersion(new Version(11, 4, 0))));&#10;&#10;// Identity - registered after DbContext so stores are available&#10;// Use full AddIdentity so SignInManager, UserManager, RoleManager and cookie handling are configured&#10;builder.Services.AddIdentity&lt;User, IdentityRole&gt;(options =&gt;&#10;{&#10;    // Optional: tweak password requirements for dev/test convenience&#10;    options.Password.RequireDigit = true;&#10;    options.Password.RequireLowercase = true;&#10;    options.Password.RequireUppercase = false;&#10;    options.Password.RequireNonAlphanumeric = false;&#10;    options.Password.RequiredLength = 6;&#10;})&#10;    .AddEntityFrameworkStores&lt;AorDbContext&gt;()&#10;    .AddDefaultTokenProviders();&#10;&#10;// Configure application cookie (custom login path)&#10;builder.Services.ConfigureApplicationCookie(options =&gt;&#10;{&#10;    options.LoginPath = &quot;/LogIn&quot;;&#10;    options.AccessDeniedPath = &quot;/LogIn/AccessDenied&quot;;&#10;});&#10;&#10;var app = builder.Build();&#10;&#10;using (var scope = app.Services.CreateScope())&#10;{&#10;    var sp = scope.ServiceProvider;&#10;    var db = sp.GetRequiredService&lt;AOR.Data.AorDbContext&gt;();&#10;&#10;    await db.Database.MigrateAsync();                 // &lt;- migrate&#10;&#10;    // Hent logger fra DI og pass bÃ¥de service provider og logger til seederen&#10;    var logger = sp.GetRequiredService&lt;ILogger&lt;Program&gt;&gt;();&#10;    await AOR.Data.AorDbSeeder.SeedAsync(sp, logger);  // &lt;- SEED (med riktige argumenter)&#10;}&#10;&#10;&#10;// Configure pipeline&#10;if (app.Environment.IsDevelopment())&#10;{&#10;    app.UseDeveloperExceptionPage();&#10;}&#10;else&#10;{&#10;    app.UseExceptionHandler(&quot;/Home/Error&quot;);&#10;    app.UseHsts();&#10;}&#10;&#10;app.UseHttpsRedirection();&#10;app.UseStaticFiles();&#10;app.UseRouting();&#10;&#10;// Disable caching so user cannot go back after logout&#10;app.Use(async (context, next) =&gt;&#10;{&#10;    context.Response.Headers[&quot;Cache-Control&quot;] = &quot;no-cache, no-store, must-revalidate&quot;;&#10;    context.Response.Headers[&quot;Pragma&quot;] = &quot;no-cache&quot;;&#10;    context.Response.Headers[&quot;Expires&quot;] = &quot;0&quot;;&#10;    await next();&#10;});&#10;&#10;app.UseAuthentication();&#10;app.UseAuthorization();&#10;&#10;app.MapControllerRoute(&#10;    name: &quot;default&quot;,&#10;    pattern: &quot;{controller=LogIn}/{action=Index}/{id?}&quot;);&#10;&#10;app.Run();&#10;" />
              <option name="updatedContent" value="using Microsoft.EntityFrameworkCore;&#10;using AOR.Data;&#10;using Microsoft.AspNetCore.Authentication.Cookies;&#10;using Microsoft.AspNetCore.Identity;&#10;&#10;&#10;var builder = WebApplication.CreateBuilder(args);&#10;&#10;// Add services&#10;builder.Services.AddControllersWithViews();&#10;&#10;// Database configuration - MySQL&#10;var connectionString = builder.Configuration.GetConnectionString(&quot;AorDb&quot;);&#10;builder.Services.AddDbContext&lt;AorDbContext&gt;(options =&gt;&#10;    options.UseMySql(connectionString, new MySqlServerVersion(new Version(11, 4, 0))));&#10;&#10;// Identity - registered after DbContext so stores are available&#10;// Use full AddIdentity so SignInManager, UserManager, RoleManager and cookie handling are configured&#10;builder.Services.AddIdentity&lt;User, IdentityRole&gt;(options =&gt;&#10;{&#10;    // Optional: tweak password requirements for dev/test convenience&#10;    options.Password.RequireDigit = true;&#10;    options.Password.RequireLowercase = true;&#10;    options.Password.RequireUppercase = false;&#10;    options.Password.RequireNonAlphanumeric = false;&#10;    options.Password.RequiredLength = 6;&#10;})&#10;    .AddEntityFrameworkStores&lt;AorDbContext&gt;()&#10;    .AddDefaultTokenProviders();&#10;&#10;// Configure application cookie (custom login path)&#10;builder.Services.ConfigureApplicationCookie(options =&gt;&#10;{&#10;    options.LoginPath = &quot;/LogIn&quot;;&#10;    options.AccessDeniedPath = &quot;/LogIn/AccessDenied&quot;;&#10;});&#10;&#10;var app = builder.Build();&#10;&#10;using (var scope = app.Services.CreateScope())&#10;{&#10;    var sp = scope.ServiceProvider;&#10;&#10;    try&#10;    {&#10;        var db = sp.GetRequiredService&lt;AOR.Data.AorDbContext&gt;();&#10;&#10;        // Migrate + seed inside try so app doesn't crash when DB isn't reachable&#10;        await db.Database.MigrateAsync();                 // &lt;- migrate&#10;&#10;        // Hent logger fra DI og pass bÃ¥de service provider og logger til seederen&#10;        var logger = sp.GetRequiredService&lt;ILogger&lt;Program&gt;&gt;();&#10;        await AOR.Data.AorDbSeeder.SeedAsync(sp, logger);  // &lt;- SEED (med riktige argumenter)&#10;    }&#10;    catch (Exception ex)&#10;    {&#10;        // If DB isn't reachable or migration fails, log and continue so web app can start&#10;        var logger = sp.GetService&lt;ILogger&lt;Program&gt;&gt;();&#10;        if (logger != null)&#10;        {&#10;            logger.LogError(ex, &quot;Database migrate/seed failed at startup. Application will continue to run.&quot;);&#10;        }&#10;        else&#10;        {&#10;            Console.Error.WriteLine(&quot;Database migrate/seed failed: &quot; + ex);&#10;        }&#10;    }&#10;}&#10;&#10;&#10;// Configure pipeline&#10;if (app.Environment.IsDevelopment())&#10;{&#10;    app.UseDeveloperExceptionPage();&#10;}&#10;else&#10;{&#10;    app.UseExceptionHandler(&quot;/Home/Error&quot;);&#10;    app.UseHsts();&#10;}&#10;&#10;app.UseHttpsRedirection();&#10;app.UseStaticFiles();&#10;app.UseRouting();&#10;&#10;// Disable caching so user cannot go back after logout&#10;app.Use(async (context, next) =&gt;&#10;{&#10;    context.Response.Headers[&quot;Cache-Control&quot;] = &quot;no-cache, no-store, must-revalidate&quot;;&#10;    context.Response.Headers[&quot;Pragma&quot;] = &quot;no-cache&quot;;&#10;    context.Response.Headers[&quot;Expires&quot;] = &quot;0&quot;;&#10;    await next();&#10;});&#10;&#10;app.UseAuthentication();&#10;app.UseAuthorization();&#10;&#10;app.MapControllerRoute(&#10;    name: &quot;default&quot;,&#10;    pattern: &quot;{controller=LogIn}/{action=Index}/{id?}&quot;);&#10;&#10;app.Run();" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/AOR/wwwroot/css/Crew.Index.css">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/AOR/wwwroot/css/Crew.Index.css" />
              <option name="updatedContent" value="/* Crew Index spesifikk styling */&#10;&#10;// ...eksisterende CSS fra Index.cshtml.css...&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>